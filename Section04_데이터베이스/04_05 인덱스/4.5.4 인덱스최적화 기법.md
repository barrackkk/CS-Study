### 인덱스는 비용이다
> 인덱스는 두 번 탐색하도록 강요
> - 읽기 비용
> > 인덱스 검색 → 실제 데이터(Row) 접근, 즉 두 번 탐색이 일어남
> >
> > 인덱스 자체는 PK처럼 별도의 자료구조, 주로 B-Tree,에 저장되어 있고, 여기서 위치를 찾은 뒤 실제 테이블에서 데이터를 읽음.
> - 쓰기 비용
> > INSERT, UPDATE, DELETE 발생 시 인덱스도 갱신해야 함.
> >
> > 특히 B-Tree 기반 인덱스는 균형을 유지해야 하므로 삽입/삭제 시 재구성 비용이 들어갑니다.
> 
> 따라서 인덱스는 무조건 많을수록 좋은 게 아니라, 읽기 최적화와 쓰기 부담 사이에서 트레이드오프가 존재.

### 항상 테스팅하라
> DB마다 쿼리 옵티마이저가 다르고, 데이터 분포/크기/패턴에 따라 효율적인 인덱스가 다름
> 
> explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함.
> 
> 즉, 인덱스는 경험칙으로 만들되, 실제 쿼리 실행 계획으로 검증해야 합니다.

### 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
> 복합 인덱스를 생성할 때 생성 순서에 따라 인덱스 성능이 달라짐
> > 1. == 조건
> >    - WHERE user_id = ? 처럼 정확히 일치하는 검색 조건을 가장 앞에 둠
> >    - 이유: B-Tree는 왼쪽에서부터 탐색하기 때문에 = 조건이 맨 앞일 떄 가장 효율적
> > 2. 정렬에 쓰는 필드(ORDER BY)
> >    - ORDER BY created_at DESC 같은 경우, 인덱스에 해당 컬럼이 포함되어 있으면 추가 정렬 작업이 생략
> >    - WHERE user_id = ? ORDER BY created_at DESC → (user_id, created_at) 인덱스가 유리.
> > 3. 다중 값을 출력해야 하는 필드 (Range condition)
> >    - BETWEEN, >, <, LIKE 'abc%' 같은 조건은 한 번 범위를 타면 인덱스의 다음 조건부터는 활용이 제한
> >    - 따라서 이들은 뒤쪽에 두는 게 좋음
> > 4. 카디널리티(Cardinality)
> >    - 카디널리티 = 값의 다양성 정도.
> >      - 예: 성별(gender)은 값이 2개 → 카디널리티 낮음.
> >      - 이메일(email)은 거의 다 다름 → 카디널리티 높음.
> >    - 카디널리티가 높은 컬럼을 뒤쪽에 배치하면 인덱스 효율이 좋음.