## 메모리 관리
> 운영체제의 대표적인 할 일
> > 컴퓨터 내의 한정된 메모리를 극한으로 활용

### 가상 메모리
> 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 사용자들에게 큰 메모리로 보이게 만드는 것
- 가상 주소: 가상적으로 주어진 주소
- 실제 주소: 실제 메모리상에 있는 주소
- 메모리관리장치(MMU): 가상 주소를 실제 주소로 변환
  - 덕분에 실제 주소 의식할 필요 없이 프로그램 구축 가능
- 페이지 테이블: 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있음.
  - 이것으로 가상 메모리 관리
  - 속도 향상을 위해 TLB 사용

#### 스와핑
>	가상 메모리의 일부 페이지를 RAM에서 내리고, 디스크의 스왑 영역(파티션/파일, HDD/SSD)에 보관했다가 필요 시 다시 올리는 동작.

#### 페이지 폴트
> 프로세스 주소 공간에는 존재하지만 실제 메모리에는 없는 데이터에 접근했을 경우 발생
> > 페이지 폴트 일어남 -> CPU 이용률 낮아짐
> 1. CPU는 물리 메모리를 확인하여 페이지가 없으면 트랩을 발생하여 운영체제에 알림
> 2. 운영체제는 CPU의 동작을 잠시 멈춤
> 3. 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인
> 3-1. 없으면 프로세스 중단 -> 현재 물리 메모리에 비어 있는 프레임 있는지 찾음 -> 물리 메모리에도 없으면 스와핑 발동
> 4. 비어 있는 프레임에 해당 페이지 로드하고, 페이지 테이블 최신화
> 5. CPU 다시 시작

### 스레싱
> 메모리의 페이지 폴트율이 높은 것을 의미 -> 성능 저하 초래
> > 메모리에 너무 많은 프로세스가 동시에 올라감 -> 스와핑 일어남 -> 스레싱 발생
> >
- 해결방안
  1. 메모리 늘리기/HDD->SSD
  2. 작업세트/PFF

#### 작업 세트
> 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것
> > 미리 메모리에 로드하면 탐색 비용 낮아짐, 스와핑 줄일 수 있음

#### PFF
> 페이지 폴트 빈도 조절하는 방법, 상한선/하한선 만듦
> > 상한선 도달 -> 프레임 늘리기/하한선 도달-> 프레임 줄이기

### 메모리 할당
> 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당
> > 연속/불연속 할당으로 나뉨

#### 연속 할당
![img.png](img.png)
> 메모리에 **연속적으로 공간** 할당하는 것
- 고정 분할 방식
  - 메모리를 미리 나누어 관리하는 방식.
  - 융퉁성 X/내부 단편화 발생
- 가변 분할 방식
  - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
  - 외부 단편화 발생할 수 있음
  - ![img_2.png](img_2.png)
- 내부 단편화: 메모리 나눈 크기 < 프로그램 크기 -> 들어가지 못하는 공간이 많이 발생하는 현상
- 외부 단편화: 메모리 나눈 크기 > 프로그램 크기 -> 들어가지 못하는 공간이 많이 발생하는 현상
  - ex) 100BM -> 55,45MB로 나눴지만 프로그램의 크기가 70MB일 때 들어가지 못하는 것
-홀: 할당할 수 있는 비어 있는 메모리 공간

#### 불연속 할당
> 메모리를 연속적으로 할당하지 않는 것
- 페이징
  - 동일한 크기의 페이지 단위로 나눔
  - 서로 다른 위치에 프로세스 할당
  - 홀의 크기가 균일하지 않는 문제 없어지지만 주소 변환 복잡해짐
- 세그멘테이션
  - 의미 단위인 세그먼트로 나누는 방식
  - 공유/보안 측면에서 장점 but 홀 크기 균열하지 않음
- 페이지드 세그멘테이션
  - 프래그램을 세그먼트로 나누는 방식
  - 공유/보안 측면에서 강점을 둠
  - 동일한 크기의 페이지 단위로 나누는 것을 말함

### 페이지 교체 알고리즘

#### 오프라인 알고리즘
- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- 하지만 미래에 사용되는 프로세스를 알 수 없기에 사용할 수 없음
- 때문에 다른 알고리즘과의 성능 비교에 대한 상한기준을 제공

#### FIFO
- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미

#### LRU
- 참조가 가장 오래된 페이지 바꿈
- **오래된** 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 함
- ![img_4.png](img_4.png)

#### NUR
- LRU에서 발전
- ![img_5.png](img_5.png)
- 1은 최근에 참조되었고 0은 참조되지 않음을 의미
- 시계 방향으로 돌면서 0을 찾음.
- 0을 찾은 순간 해당 프로세스를 교체, 해당 부분을 1로 바꾸는 알고리즘

#### LFU
- 가장 참조 횟수가 적은 페이지 교체
- 즉 많이 사용되지 않은 것을 교체